import { PayloadAction, createAsyncThunk, createSlice } from '@reduxjs/toolkit';

import {
	createConversationByUser,
	deleteConversationById,
	deleteMessageById,
	fetchMyConversationById,
	fetchMyConversations,
	sendMessageByConversationId,
	updateConversationById
} from '@/services/conversation.service';
import type { AppState, AppThunk } from '@/store/store';

export interface ConversationState {
	conversations: TConversationInList[];
	currentConversation: IConversation | undefined;
	conversationsStatus: TStateAsyncStatus;
	currentConversationStatus: TStateAsyncStatus;
}

const initialState: ConversationState = {
	conversations: [],
	currentConversation: undefined,
	conversationsStatus: 'idle',
	currentConversationStatus: 'idle'
};

export const fetchMyConversationsAsync = createAsyncThunk(
	'conversation/fetchMyConversations',
	async () => {
		const response = await fetchMyConversations();
		return response.data.docs;
	}
);

export const fetchMyConversationByIdAsync = createAsyncThunk(
	'conversation/fetchMyConversationById',
	async (id: string) => {
		const response = await fetchMyConversationById(id);
		return response.data;
	}
);

export const ConversationSlice = createSlice({
	name: 'conversation',
	initialState,
	reducers: {
		// Use the PayloadAction type to declare the contents of `action.payload`
		updateConversations: (state, action: PayloadAction<TConversationInList[]>) => {
			state.conversations = action.payload;
		},
		addMessageToCurrentConversation: (state, action: PayloadAction<IMessage>) => {
			if (state.currentConversation) {
				state.currentConversation.messages.push(action.payload);
			}
		},
		updateCurrentConversation: (
			state,
			action: PayloadAction<Partial<IConversation> | IConversation>
		) => {
			let conversation: IConversation;
			if (state.currentConversation) {
				conversation = {
					...state.currentConversation,
					...action.payload
				};
			} else {
				conversation = action.payload as IConversation;
			}
			state.currentConversation = conversation;
			// update the conversation in the list
			const index = state.conversations.findIndex(
				item => item.id === state.currentConversation?.id
			);
			if (index !== -1) {
				state.conversations[index] = state.currentConversation;
			}
		},
		unselectCurrentConversation: state => {
			state.currentConversation = undefined;
		}
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
	// including actions generated by createAsyncThunk or in other slices.
	extraReducers: builder => {
		builder
			// conversations
			.addCase(fetchMyConversationsAsync.pending, state => {
				state.conversationsStatus = 'loading';
			})
			.addCase(fetchMyConversationsAsync.fulfilled, (state, action) => {
				state.conversationsStatus = 'idle';
				state.conversations = action.payload;
			})
			// current conversation
			.addCase(fetchMyConversationByIdAsync.pending, state => {
				state.currentConversationStatus = 'loading';
			})
			.addCase(fetchMyConversationByIdAsync.fulfilled, (state, action) => {
				state.currentConversationStatus = 'idle';
				state.currentConversation = action.payload;
			});
	}
});

export const {
	updateConversations,
	addMessageToCurrentConversation,
	updateCurrentConversation,
	unselectCurrentConversation
} = ConversationSlice.actions;

export const selectConversationState = (state: AppState) => state.conversation;

// write thunks by hand

export const fetchConversations = (): AppThunk => async dispatch => {
	const conversationsResponse = await fetchMyConversations();
	dispatch(updateConversations(conversationsResponse.data.docs));
};

export const createConversation =
	(payload: TCreateConversationPayload): AppThunk =>
	async (dispatch, getState) => {
		const conversationResponse = await createConversationByUser(payload);
		if (conversationResponse.status === 201) {
			const { conversations } = getState().conversation;
			dispatch(updateConversations([conversationResponse.data.doc, ...conversations]));
			dispatch(updateCurrentConversation(conversationResponse.data.doc));
		}
	};

// This is used for updating a conversation, except for the chat history
export const updateConversation =
	(payload: TUpdateConversationPayload): AppThunk =>
	async (dispatch, getState) => {
		const conversationResponse = await updateConversationById(payload);
		if (conversationResponse.status === 200) {
			const { currentConversation, conversations } = getState().conversation;
			if (currentConversation?.id === payload.id) {
				dispatch(updateCurrentConversation(payload));
			}
			if (conversations?.some(conversation => conversation.id === payload.id)) {
				dispatch(
					updateConversations(
						conversations.map(conversation => {
							if (conversation.id === payload.id) {
								return {
									...conversation,
									...payload
								};
							}
							return conversation;
						})
					)
				);
			}
		}
	};

export const deleteConversation =
	(id: string): AppThunk =>
	async (dispatch, getState) => {
		const deleteResponse = await deleteConversationById(id);
		if (deleteResponse.status === 200) {
			const { currentConversation, conversations } = getState().conversation;
			if (currentConversation?.id === id) {
				dispatch(unselectCurrentConversation());
			}
			if (conversations?.some(conversation => conversation.id === id)) {
				dispatch(
					updateConversations(
						conversations.filter(conversation => conversation.id !== id)
					)
				);
			}
		}
	};

export const sendMessage =
	(payload: ISendMessagePayload): AppThunk =>
	async (dispatch, getState) => {
		const response = await sendMessageByConversationId(payload);
		if (response.status === 200) {
			const AIMessage = response.data;
			const { currentConversation } = getState().conversation;
			if (currentConversation?.id === payload.id) {
				dispatch(
					updateCurrentConversation({
						messages: [...(currentConversation.messages || []), AIMessage]
					})
				);
			}
		}
	};

export const deleteMessageByMessageId =
	(conversationId: string, messageId: string): AppThunk =>
	async (dispatch, getState) => {
		const response = await deleteMessageById(conversationId, messageId);
		if (response.status === 200) {
			const { currentConversation } = getState().conversation;
			if (currentConversation?.id === conversationId) {
				const messageIndex = currentConversation.messages.findIndex(
					item => item.id === messageId
				);
				if (messageIndex > -1) {
					dispatch(
						updateCurrentConversation({
							messages: currentConversation.messages.slice(0, messageIndex)
						})
					);
				}
			}
		}
	};

export default ConversationSlice.reducer;
